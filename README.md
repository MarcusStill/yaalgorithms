# yaalgorithms
Solving problems in Algorithms courses from Yandex Practicum

---

<details>
<summary>
<b>Мониторинг (<a href="sprint_2/monitoring.py">monitoring.py</a></b>)
</summary>

#### Условие
Алла получила задание, связанное с мониторингом работы различных серверов. 
Требуется понять, сколько времени обрабатываются определённые запросы на конкретных серверах. 
Эту информацию нужно хранить в матрице, где номер столбца соответствуют идентификатору запроса, 
а номер строки — идентификатору сервера. Алла перепутала строки и столбцы местами. 
С каждым бывает. Помогите ей исправить баг.

Есть матрица размера m × n. Нужно написать функцию, которая её транспонирует.

Транспонированная матрица получается из исходной заменой строк на столбцы.

#### Формат ввода
В первой строке задано число n — количество строк матрицы.
Во второй строке задано m — число столбцов, m и n не превосходят 1000. В следующих n строках задана матрица. 
Числа в ней не превосходят по модулю 1000.

#### Формат вывода
Напечатайте транспонированную матрицу в том же формате, который задан во входных данных. 
Каждая строка матрицы выводится на отдельной строке, элементы разделяются пробелами.

#### Пример
<table><tbody>
  <tr>
    <td><b>Ввод</b></td>
    <td><b>Вывод</b></td>
  </tr>
  <tr>
    <td valign='top'>
4<br>
3<br>
1 2 3<br>
0 2 6<br>
7 4 1<br>
2 7 0<br>

</td>
  <td valign='top'>
1 0 7 2<br>
2 2 4 7<br>
3 6 1 0<br>
</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Стек - MaxEffective (<a href="sprint_2/stack_max_effective.py">stack_max_effective.py</a></b>)
</summary>

#### Условие
Реализуйте класс `StackMaxEffective`, 
поддерживающий операцию определения максимума среди элементов в стеке. 
Сложность операции должна быть O(1). Для пустого стека операция должна возвращать `None`. 
При этом `push(x)` и `pop()` также должны выполняться за константное время.

#### Формат ввода
В первой строке записано одно число — количество команд, оно не превосходит 100000. 
Далее идут команды по одной в строке. Команды могут быть следующих видов:

* `push(x)` — добавить число x в стек;
* `pop()` — удалить число с вершины стека;
* `get_max()` — напечатать максимальное число в стеке;

Если стек пуст, при вызове команды get_max нужно напечатать «None», для команды pop — «error».

#### Формат вывода
Для каждой команды `get_max()` напечатайте результат её выполнения. 
Если стек пустой, для команды `get_max()` напечатайте «None». 
Если происходит удаление из пустого стека — напечатайте «error»

#### Пример
<table><tbody>
  <tr>
    <td><b>Ввод</b></td>
    <td><b>Вывод</b></td>
  </tr>
  <tr>
    <td valign="top">
10<br>
pop<br>
pop<br>
push 4<br>
push -5<br>
push 7<br>
pop<br>
pop<br>
get_max<br>
pop<br>
get_max<br>
</td>
    <td valign="top">
error<br>
error<br>
4<br>
None<br>
</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Скобочная последовательность (<a href="sprint_2/brackets.py">brackets.py</a></b>)
</summary>

#### Условие
Вот какую задачу Тимофей предложил на собеседовании одному из кандидатов. Если вы с ней ещё не сталкивались, то наверняка столкнётесь –— она довольно популярная.

Дана скобочная последовательность. Нужно определить, правильная ли она.

Будем придерживаться такого определения:

* пустая строка —– правильная скобочная последовательность;
* правильная скобочная последовательность, взятая в скобки одного типа, –— правильная скобочная последовательность;
* правильная скобочная последовательность с приписанной слева или справа правильной скобочной последовательностью —– тоже правильная.

На вход подаётся последовательность из скобок трёх видов: [], (), {}.
Напишите функцию `is_correct_bracket_seq`, которая принимает на вход скобочную последовательность и возвращает `True`, 
если последовательность правильная, а иначе `False`.

#### Формат ввода
На вход подаётся одна строка, содержащая скобочную последовательность. Скобки записаны подряд, без пробелов.

#### Формат вывода
Выведите «True» или «False».

#### Пример
<table><tbody>
  <tr>
    <td><b>Ввод</b></td>
    <td><b>Вывод</b></td>
  </tr>
  <tr>
    <td valign="top">
{[()]}
</td>
    <td valign="top">
True
</td>
  </tr>
<tr>
    <td valign="top">
{}
</td>
    <td valign="top">
True
</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Ограниченная очередь (<a href="sprint_2/queue_sized.py">queue_sized.py</a></b>)
</summary>

#### Условие
Астрологи объявили день очередей ограниченного размера. 
Тимофею нужно написать класс `MyQueueSized`, который принимает параметр `max_size`, 
означающий максимально допустимое количество элементов в очереди.

Помогите ему —– реализуйте программу, которая будет эмулировать работу такой очереди.
Функции, которые надо поддержать, описаны в формате ввода.

#### Формат ввода
В первой строке записано одно число — количество команд, оно не превосходит 5000.
Во второй строке задан максимально допустимый размер очереди, он не превосходит 5000.
Далее идут команды по одной на строке. Команды могут быть следующих видов:

* `push(x)` — добавить число x в очередь;
* `pop()` — удалить число из очереди и вывести на печать;
* `peek()` — напечатать первое число в очереди;
* `size()` — вернуть размер очереди;
При превышении допустимого размера очереди нужно вывести «error». 
При вызове операций `pop()` или `peek()` для пустой очереди нужно вывести «None».

#### Формат вывода
Напечатайте результаты выполнения нужных команд, по одному на строке.

#### Пример
<table><tbody>
  <tr>
    <td><b>Ввод</b></td>
    <td><b>Вывод</b></td>
  </tr>
  <tr>
    <td valign="top">
8<br>
2<br>
peek<br>
push 5<br>
push 2<br>
peek<br>
size<br>
size<br>
push 1<br>
size<br>

</td>
    <td valign="top">
None<br>
5<br>
2<br>
2<br>
error<br>
2<br>

</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Списочная очередь (<a href="sprint_2/queue_list.py">queue_list.py</a></b>)
</summary>

#### Условие
Любимый вариант очереди Тимофея — очередь, написанная с использованием связного списка. 
Помогите ему с реализацией. Очередь должна поддерживать выполнение трёх команд:

* `get()` — вывести элемент, находящийся в голове очереди, и удалить его. Если очередь пуста, то вывести «error».
* `put(x)` — добавить число x в очередь
* `size()` — вывести текущий размер очереди

#### Формат ввода
В первой строке записано количество команд n — целое число, не превосходящее 1000. 
В каждой из следующих n строк записаны команды по одной строке.

#### Формат вывода
Выведите ответ на каждый запрос по одному в строке.

#### Пример
<table><tbody>
  <tr>
    <td><b>Ввод</b></td>
    <td><b>Вывод</b></td>
  </tr>
  <tr>
    <td valign="top">
10<br>
put -34<br>
put -23<br>
get<br>
size<br>
get<br>
size<br>
get<br>
get<br>
put 80<br>
size<br>

</td>
    <td valign="top">
-34<br>
1<br>
-23<br>
0<br>
error<br>
error<br>
1<br>

</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Рекурсивные числа Фибоначчи (<a href="sprint_2/fibonacci.py">fibonacci.py</a></b>)
</summary>

#### Условие
У Тимофея было n стажёров. 
Каждый стажёр хотел быть лучше своих предшественников, 
поэтому стажёр делал столько коммитов, 
сколько делали два предыдущих стажёра в сумме. 
Два первых стажёра были менее инициативными —– они сделали по одному коммиту.

Определите, сколько кода напишет следующий стажёр.
Решение должно быть реализовано рекурсивно.

#### Формат ввода
На вход подаётся n — целое число в диапазоне от 0 до 32.

#### Формат вывода
Нужно вывести, сколько кода напишет следующий стажёр.

#### Пример
<table><tbody>
  <tr>
    <td><b>Ввод</b></td>
    <td><b>Вывод</b></td>
  </tr>
  <tr>
    <td valign="top">
3
</td>
    <td valign="top">
3
</td>
  </tr>
  <tr>
    <td valign="top">
0
</td>
    <td valign="top">
1
</td>
  </tr>
  <tr>
    <td valign="top">
1
</td>
    <td valign="top">
1
</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Дек (<a href="sprint_2/deck.py">deck.py</a></b>)
</summary>

#### Условие

Гоша реализовал структуру данных Дек, максимальный размер которого определяется заданным числом. 
Методы `push_back(x)`, `push_front(x)`, `pop_back()`, `pop_front()` работали корректно. 
Но, если в деке было много элементов, программа работала очень долго. 
Дело в том, что не все операции выполнялись за O(1). 
Помогите Гоше! Напишите эффективную реализацию.

**Внимание: при реализации нельзя использовать связный список.**

#### Формат ввода
В первой строке записано количество команд n — целое число, не превосходящее 100000. Во второй строке записано число m — максимальный размер дека. Он не превосходит 50000. В следующих n строках записана одна из команд:

* `push_back(value)` – добавить элемент в конец дека. Если в деке уже находится максимальное число элементов, вывести «error».
* `push_front(value)` – добавить элемент в начало дека. Если в деке уже находится максимальное число элементов, вывести «error».
* `pop_front()` – вывести первый элемент дека и удалить его. Если дек был пуст, то вывести «error».
* `pop_back()` – вывести последний элемент дека и удалить его. Если дек был пуст, то вывести «error».
`value` — целое число, по модулю не превосходящее 1000.

#### Формат вывода
Выведите результат выполнения каждой команды на отдельной строке. 
Для успешных запросов `push_back(x)` и `push_front(x)` ничего выводить не надо.

#### Пример
<table><tbody>
  <tr>
    <td><b>Ввод</b></td>
    <td><b>Вывод</b></td>
  </tr>
  <tr>
    <td valign="top">
4<br>
4<br>
push_front 861<br>
push_front -819<br>
pop_back<br>
pop_back<br>

</td>
    <td valign="top">
861<br>
-819<br>

</td>
  </tr>
</tbody></table>

</details>

---

<details>
<summary>
<b>Калькулятор (<a href="sprint_2/polsk_calc.py">polsk_calc.py</a></b>)
</summary>

#### Условие
Задание связано с обратной польской нотацией. 
Она используется для парсинга арифметических выражений. 
Еще её иногда называют постфиксной нотацией.

В постфиксной нотации операнды расположены перед знаками операций.

**Пример:**

10 2 4 * 

означает 10 - 2 * 4 и равно 2

Разберём последний пример подробнее:

Знак * стоит сразу после чисел 2 и 4, значит к ним нужно применить операцию, которую этот знак обозначает, то есть перемножить эти два числа. В результате получим 8.

После этого выражение приобретёт вид:

10 8 -

Операцию «минус» нужно применить к двум идущим перед ней числам, то есть 10 и 8. В итоге получаем 2.

Рассмотрим алгоритм более подробно. Для его реализации будем использовать стек.

Для вычисления значения выражения, записанного в обратной польской нотации, 
нужно считывать выражение слева направо и придерживаться следующих шагов:

1. Обработка входного символа:
Если на вход подан операнд, он помещается на вершину стека.
Если на вход подан знак операции, то эта операция выполняется над требуемым количеством значений, взятых из стека в порядке добавления. Результат выполненной операции помещается на вершину стека.
2. Если входной набор символов обработан не полностью, перейти к шагу 1.
3. После полной обработки входного набора символов результат вычисления выражения находится в вершине стека. Если в стеке осталось несколько чисел, то надо вывести только верхний элемент.

**Замечание про отрицательные числа и деление:** 
в этой задаче под делением понимается математическое целочисленное деление. 
Это значит, что округление всегда происходит вниз. 
А именно: если a / b = c, то b ⋅ c — это наибольшее число, 
которое не превосходит a и одновременно делится без остатка на b.

Например, -1 / 3 = -1. Будьте осторожны: в C++, Java и Go, например, деление чисел работает иначе.

В текущей задаче гарантируется, что деления на отрицательное число нет.

#### Формат ввода
В единственной строке дано выражение, записанное в обратной польской нотации. Числа и арифметические операции записаны через пробел.

На вход могут подаваться операции: +, -, *, / и числа, по модулю не превосходящие 10000.

Гарантируется, что значение промежуточных выражений в тестовых данных по модулю не больше 50000.

#### Формат вывода
Выведите единственное число — значение выражения.

#### Пример
<table><tbody>
  <tr>
    <td><b>Ввод</b></td>
    <td><b>Вывод</b></td>
  </tr>
  <tr>
    <td valign="top">
2 1 + 3 *

</td>
    <td valign="top">
9

</td>
  </tr>
</tbody></table>

</details>

---